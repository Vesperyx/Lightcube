import numpy as np
import threading
import pyaudio
import time
import sys
import os
import collections

# -------------------------------
# Invariant Measure Functions for Audio
# -------------------------------
def process_invariant_1d(U, psi, r=1.0, dx=1.0):
    """
    Process a 1D function U (e.g., audio signal) via the invariant measure framework.
    Returns the decoded function U_decoded with EXACT same length as input.
    """
    input_length = len(U)
    integral_exp = np.sum(np.exp(2 * U / r) * dx)
    n = (r / 2) * np.log(integral_exp)
    P = (psi**2) * np.exp(2 * (U - n) / r)
    U_decoded = n + (r / 2) * np.log(P / (psi**2))
    
    # Ensure output length matches input length exactly
    assert len(U_decoded) == input_length, f"Length mismatch: input {input_length}, output {len(U_decoded)}"
    return U_decoded

def create_gaussian_wavefunction_1d(length, sigma_factor=0.5):
    """Create a normalized 1D Gaussian wavefunction for a given length."""
    center = (length - 1) / 2.0
    sigma = sigma_factor * (length / 2.0)
    x = np.arange(length)
    sq_dist = ((x - center) ** 2) / (2 * sigma**2)
    psi = np.exp(-sq_dist)
    norm = np.sqrt(np.sum(psi**2))
    return psi / norm

# -------------------------------
# Audio Feedback and Prediction System
# -------------------------------
class AudioFeedbackBuffer:
    """Ring buffer for managing audio feedback and prediction"""
    def __init__(self, max_size=10, chunk_size=1024):
        self.buffer = collections.deque(maxlen=max_size)
        self.chunk_size = chunk_size
        self.feedback_level = 0.3  # Default feedback level (0.0 to 1.0)
        self.mic_level = 0.7       # Default microphone level (0.0 to 1.0)
        self.prediction_level = 0.5  # Default prediction level (0.0 to 1.0)
        
    def add_output(self, audio_array):
        """Add processed output to the buffer"""
        # Make a copy to avoid reference issues
        self.buffer.append(audio_array.copy())
        
    def get_feedback(self):
        """Get mixed feedback from the buffer"""
        if not self.buffer:
            return np.zeros(self.chunk_size, dtype=np.float64)
        
        # Calculate the average of all samples in the buffer to create a feedback signal
        # This creates a richer feedback sound than just using the most recent output
        feedback = np.zeros(self.chunk_size, dtype=np.float64)
        count = 0
        
        for sample in self.buffer:
            feedback += sample
            count += 1
            
        if count > 0:
            feedback /= count
            
        return feedback
    
    def mix_with_input(self, input_array):
        """Mix the feedback with new input using current levels"""
        feedback = self.get_feedback()
        
        # Scale each component by its level and ensure they sum to 1.0
        total = self.mic_level + self.feedback_level
        if total == 0:
            # Avoid division by zero
            normalized_mic = 1.0
            normalized_feedback = 0.0
        else:
            normalized_mic = self.mic_level / total
            normalized_feedback = self.feedback_level / total
        
        # Mix input with feedback, maintaining overall amplitude
        result = (normalized_mic * input_array) + (normalized_feedback * feedback)
        
        return result
    
    def mix_with_prediction(self, processed, predicted):
        """Mix processed audio with its prediction"""
        # Scale based on prediction level
        result = (1.0 - self.prediction_level) * processed + self.prediction_level * predicted
        return result
    
    def adjust_levels(self, feedback_level=None, mic_level=None, prediction_level=None):
        """Adjust the feedback, microphone, and prediction levels"""
        if feedback_level is not None:
            self.feedback_level = max(0.0, min(1.0, feedback_level))
        if mic_level is not None:
            self.mic_level = max(0.0, min(1.0, mic_level))
        if prediction_level is not None:
            self.prediction_level = max(0.0, min(1.0, prediction_level))
            
        print(f"Levels - Mic: {self.mic_level:.2f}, Feedback: {self.feedback_level:.2f}, Prediction: {self.prediction_level:.2f}")

# -------------------------------
# Global variables for prediction and thread coordination
# -------------------------------
global_last_audio = None
running = True
feedback_buffer = None  # Will be initialized in audio thread

# -------------------------------
# Audio Processing 
# -------------------------------
def audio_thread():
    global global_last_audio, running, feedback_buffer
    
    p = pyaudio.PyAudio()
    FORMAT = pyaudio.paInt16
    CHANNELS = 1
    RATE = 16000
    CHUNK = 1024
    
    # Try to open audio streams with retry logic
    stream_in = None
    stream_out = None
    
    # List available audio devices
    print("\nAvailable audio input devices:")
    for i in range(p.get_device_count()):
        dev_info = p.get_device_info_by_index(i)
        if dev_info['maxInputChannels'] > 0:
            print(f"  Input Device {i}: {dev_info['name']}")
    
    print("\nAvailable audio output devices:")
    for i in range(p.get_device_count()):
        dev_info = p.get_device_info_by_index(i)
        if dev_info['maxOutputChannels'] > 0:
            print(f"  Output Device {i}: {dev_info['name']}")
    
    # Find default devices
    default_input = p.get_default_input_device_info()['index'] if p.get_default_input_device_info() else 0
    default_output = p.get_default_output_device_info()['index'] if p.get_default_output_device_info() else 0
    
    print(f"\nUsing default input device: {default_input}")
    print(f"Using default output device: {default_output}")
    
    # Try to open audio streams
    max_retries = 5
    
    for retry in range(max_retries):
        try:
            print(f"Attempt {retry+1}/{max_retries} to open audio streams...")
            stream_in = p.open(format=FORMAT, channels=CHANNELS, rate=RATE,
                              input=True, frames_per_buffer=CHUNK,
                              input_device_index=default_input)
            stream_out = p.open(format=FORMAT, channels=CHANNELS, rate=RATE,
                               output=True, frames_per_buffer=CHUNK,
                               output_device_index=default_output)
            break
        except Exception as e:
            print(f"Error opening audio streams: {e}")
            # Clean up any partially opened streams
            if stream_in:
                try:
                    stream_in.close()
                except:
                    pass
                stream_in = None
            if stream_out:
                try:
                    stream_out.close()
                except:
                    pass
                stream_out = None
            
            if retry == max_retries - 1:
                print("Failed to open audio streams after multiple attempts")
                running = False
                return
            
            # Wait before retry
            wait_time = 2 * (retry + 1)
            print(f"Waiting {wait_time} seconds before retry...")
            time.sleep(wait_time)
    
    # Create feedback buffer (stores several chunks of past output for feedback)
    feedback_buffer = AudioFeedbackBuffer(max_size=5, chunk_size=CHUNK)
    
    # Invariant measure parameters
    r = 1.0  # scale parameter for audio
    
    print("\nAudio processing started with self-feedback AND prediction.")
    print(f"Processing audio chunks of exactly {CHUNK} samples at {RATE}Hz")
    print(f"Initial settings:")
    print(f"  - Mic level: {feedback_buffer.mic_level:.2f}")
    print(f"  - Feedback level: {feedback_buffer.feedback_level:.2f}")
    print(f"  - Prediction level: {feedback_buffer.prediction_level:.2f}")
    print("Controls:")
    print("  - Press Ctrl+C to stop")
    print("  - Press + or - to adjust feedback level up/down")
    print("  - Press m or n to adjust microphone level up/down")
    print("  - Press p or o to adjust prediction level up/down")
    
    # Create a template Gaussian wavefunction for the chunk size
    # (Creating it once instead of every iteration improves performance)
    template_psi = create_gaussian_wavefunction_1d(CHUNK, sigma_factor=0.5)
    
    # Stats tracking
    processed_chunks = 0
    start_time = time.time()
    last_report_time = start_time
    
    while running:
        try:
            # Read exact CHUNK size from microphone
            data = stream_in.read(CHUNK, exception_on_overflow=False)
            mic_audio = np.frombuffer(data, dtype=np.int16).astype(np.float64) / 32768.0
            
            # Verify input size
            assert len(mic_audio) == CHUNK, f"Input audio chunk size mismatch: {len(mic_audio)} vs {CHUNK}"
            
            # Mix input with feedback
            mixed_audio = feedback_buffer.mix_with_input(mic_audio)
            
            # Process mixed audio using invariant measure
            audio_decoded = process_invariant_1d(mixed_audio, template_psi, r=r, dx=1.0)
            
            # Verify processed size
            assert len(audio_decoded) == CHUNK, f"Processed audio size mismatch: {len(audio_decoded)} vs {CHUNK}"
            
            # Prediction: linear extrapolation
            if global_last_audio is None or len(global_last_audio) != len(audio_decoded):
                audio_predicted = audio_decoded.copy()
            else:
                # This is the key predictive component from the original code:
                # Predict next frame by adding the difference between current and previous
                audio_predicted = audio_decoded + (audio_decoded - global_last_audio)
                
            # Store current processed frame for next iteration's prediction
            global_last_audio = audio_decoded.copy()
            
            # Mix processed audio with prediction based on prediction level
            final_output = feedback_buffer.mix_with_prediction(audio_decoded, audio_predicted)
            
            # Add final output to feedback buffer for future iterations
            feedback_buffer.add_output(final_output)
            
            # Prepare output (clip to prevent distortion)
            audio_out = np.clip(final_output, -1.0, 1.0)
            
            # Convert to bytes for output
            audio_out_bytes = (audio_out * 32767).astype(np.int16).tobytes()
            
            # Verify output length in bytes
            expected_bytes = CHUNK * 2  # 16-bit = 2 bytes per sample
            assert len(audio_out_bytes) == expected_bytes, f"Output audio byte size mismatch: {len(audio_out_bytes)} vs {expected_bytes}"
            
            # Send to speaker
            stream_out.write(audio_out_bytes)
            
            # Update stats
            processed_chunks += 1
            current_time = time.time()
            elapsed = current_time - last_report_time
            
            # Print stats every 5 seconds
            if elapsed >= 5.0:
                chunks_per_second = processed_chunks / (current_time - start_time)
                print(f"Stats: Processed {processed_chunks} audio chunks ({chunks_per_second:.1f} chunks/sec)")
                last_report_time = current_time
                
        except Exception as e:
            print(f"Audio processing error: {e}")
            import traceback
            traceback.print_exc()
            time.sleep(0.1)  # Prevent tight loop on errors
    
    # Clean up
    try:
        if stream_in:
            stream_in.stop_stream()
            stream_in.close()
        if stream_out:
            stream_out.stop_stream()
            stream_out.close()
        p.terminate()
    except Exception as e:
        print(f"Error during audio cleanup: {e}")
    
    print("Audio processing terminated.")

# -------------------------------
# Keyboard Control Thread
# -------------------------------
def keyboard_control_thread():
    """Thread to handle keyboard controls for feedback adjustment"""
    global running, feedback_buffer
    
    # Wait for audio thread to create the feedback buffer
    while running and feedback_buffer is None:
        time.sleep(0.1)
    
    if not running:
        return
    
    print("Keyboard controls active.")
    
    if sys.platform == 'win32':
        import msvcrt
        
        while running:
            if msvcrt.kbhit():
                key = msvcrt.getch().decode('utf-8', errors='ignore')
                if key == '+':
                    feedback_buffer.adjust_levels(feedback_level=feedback_buffer.feedback_level + 0.1)
                elif key == '-':
                    feedback_buffer.adjust_levels(feedback_level=feedback_buffer.feedback_level - 0.1)
                elif key.lower() == 'm':
                    feedback_buffer.adjust_levels(mic_level=feedback_buffer.mic_level + 0.1)
                elif key.lower() == 'n':
                    feedback_buffer.adjust_levels(mic_level=feedback_buffer.mic_level - 0.1)
                elif key.lower() == 'p':
                    feedback_buffer.adjust_levels(prediction_level=feedback_buffer.prediction_level + 0.1)
                elif key.lower() == 'o':
                    feedback_buffer.adjust_levels(prediction_level=feedback_buffer.prediction_level - 0.1)
            time.sleep(0.1)
    else:
        # Unix-like systems
        import termios, tty, select
        
        old_settings = termios.tcgetattr(sys.stdin)
        try:
            tty.setcbreak(sys.stdin.fileno())
            
            while running:
                if select.select([sys.stdin], [], [], 0) == ([sys.stdin], [], []):
                    key = sys.stdin.read(1)
                    if key == '+':
                        feedback_buffer.adjust_levels(feedback_level=feedback_buffer.feedback_level + 0.1)
                    elif key == '-':
                        feedback_buffer.adjust_levels(feedback_level=feedback_buffer.feedback_level - 0.1)
                    elif key.lower() == 'm':
                        feedback_buffer.adjust_levels(mic_level=feedback_buffer.mic_level + 0.1)
                    elif key.lower() == 'n':
                        feedback_buffer.adjust_levels(mic_level=feedback_buffer.mic_level - 0.1)
                    elif key.lower() == 'p':
                        feedback_buffer.adjust_levels(prediction_level=feedback_buffer.prediction_level + 0.1)
                    elif key.lower() == 'o':
                        feedback_buffer.adjust_levels(prediction_level=feedback_buffer.prediction_level - 0.1)
                time.sleep(0.1)
        finally:
            termios.tcsetattr(sys.stdin, termios.TCSADRAIN, old_settings)

# =============================================================================
# Main: Start Audio and Keyboard Threads
# =============================================================================
if __name__ == "__main__":
    try:
        print("\n=== Audio Processor with Self-Feedback AND Prediction ===")
        print("This system combines self-feedback with predictive processing")
        print("Starting audio processing...")
        
        # Create and start audio thread
        aud_thread = threading.Thread(target=audio_thread, name="AudioThread")
        aud_thread.start()
        
        # Create keyboard control thread
        keyboard_thread = threading.Thread(target=keyboard_control_thread, name="KeyboardThread")
        keyboard_thread.daemon = True  # This thread will exit when main thread exits
        keyboard_thread.start()
        
        # Wait for keyboard interrupt in main thread
        try:
            while running and aud_thread.is_alive():
                time.sleep(0.1)
        except KeyboardInterrupt:
            print("\nKeyboard interrupt detected. Shutting down...")
            running = False
        
        # Wait for audio thread to finish
        if aud_thread.is_alive():
            aud_thread.join(timeout=2.0)
        
    except Exception as e:
        print(f"Error in main thread: {e}")
        running = False
    finally:
        print("\nProgram terminated.")
